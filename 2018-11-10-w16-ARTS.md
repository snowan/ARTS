## Week 9 ARTS

### [A] - LC 200, 211
---
```java
package leetcode;

/**
 * 200. Number of Islands
 * Given a 2d grid map of '1's (land) and '0's (water), count the number of islands.
 * An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.
 * You may assume all four edges of the grid are all surrounded by water.
 *
 * Example 1:
 *
 * Input:
 * 11110
 * 11010
 * 11000
 * 00000
 *
 * Output: 1
 * Example 2:
 *
 * Input:
 * 11000
 * 11000
 * 00100
 * 00011
 *
 * Output: 3
 *
 */
public class NumberOfIsland200 {
  // DFS solution, time: O(V + E)
  public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) return 0;
    int count = 0;
    for (int i = 0; i < grid.length; i++) {
      for (int j = 0; j < grid[0].length; j++) {
        if (grid[i][j] == '1') {
          count++;
          mergeIsland(grid, i, j);
        }
      }
    }
    return count;
  }

  // Merging adjacent islands
  private void mergeIsland(char[][] grid, int i, int j) {
    if (i < 0 || j < 0
        || i >= grid.length || j >= grid[0].length
        || grid[i][j] != '1') return;
    // marked visited
    grid[i][j] = 'X';
    mergeIsland(grid, i + 1, j);
    mergeIsland(grid, i - 1, j);
    mergeIsland(grid, i, j + 1);
    mergeIsland(grid, i, j - 1);
  }
}
```
```java
package leetcode;

import java.util.HashMap;
import java.util.Map;

/**
 * 211. Add and Search Word
 *
 * Design a data structure that supports the following two operations:
 *
 * void addWord(word)
 * bool search(word)
 * search(word) can search a literal word or a regular expression string containing
 * only letters a-z or .. A . means it can represent any one letter.
 *
 * Example:
 *
 * addWord("bad")
 * addWord("dad")
 * addWord("mad")
 * search("pad") -> false
 * search("bad") -> true
 * search(".ad") -> true
 * search("b..") -> true
 * Note:
 * You may assume that all words are consist of lowercase letters a-z.
 *
 *
 */
public class AddAndSearchWord211 {
  TrieTree root;


  /** Adds a word into the data structure. */
  public void addWord(String word) {
    root.insert(word);
  }

  /** Returns if the word is in the data structure.
   * A word could contain the dot character '.' to represent any one letter.
   */
  public boolean search(String word) {
    return root.search(word);
  }

  public AddAndSearchWord211() {
    root = new TrieTree();
  }

  /**
   * Your WordDictionary object will be instantiated and called as such:
   * WordDictionary obj = new WordDictionary();
   * obj.addWord(word);
   * boolean param_2 = obj.search(word);
   */

  public static void main(String[] args) {
    AddAndSearchWord211 test = new AddAndSearchWord211();
    test.addWord("bad");
    test.addWord("dad");
    test.addWord("mad");
    System.out.println(test.search("pad"));
    System.out.println(test.search("bad"));
    System.out.println(test.search(".ad"));
    System.out.println(test.search("b.."));
  }
}

// solution: building a trie tree, insert character by character,
// using map to insert children
class TrieTree {
  TrieNode root;

  public TrieTree() {
    root = new TrieNode();
  }

  public void insert(String word) {
    Map<Character, TrieNode> children = root.children;
    for (int i = 0; i < word.length(); i++) {
      char c = word.charAt(i);
      TrieNode node;
      if (children.containsKey(c)) {
        node = children.get(c);
      } else {
        node = new TrieNode(c);
        children.put(c, node);
      }
      children = node.children;
      if (i == word.length() - 1) {
        node.isWord = true;
      }
    }
  }

  public boolean search(String word) {
    return searchWord(word, 0, root);
  }

  public boolean searchWord(String word, int idx, TrieNode node) {
    if (idx == word.length()) {
      return node.isWord;
    }
    char curr = word.charAt(idx);
    Map<Character, TrieNode> children = node.children;
    if (curr == '.') {
      for (Map.Entry<Character, TrieNode> entry : children.entrySet()) {
        if (searchWord(word, idx + 1, entry.getValue())) {
          return true;
        }
      }
      return false;
    } else if (children.containsKey(curr)) {
      return searchWord(word, idx + 1, children.get(curr));
    }
    return false;
  }
}

class TrieNode {
  char ch;
  Map<Character, TrieNode> children;
  boolean isWord;

  public TrieNode() {
    children = new HashMap<>();
  }

  public TrieNode(char ch) {
    this.ch = ch;
    children = new HashMap<>();
  }
}
```
```java
package leetcode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 15. 3Sum
 *
 * Given an array nums of n integers, are there elements a, b, c in nums such that a +
 * b + c = 0? Find all unique triplets in the array which gives the sum of zero.
 *
 * Note:
 *
 * The solution set must not contain duplicate triplets.
 *
 * Example:
 *
 * Given array nums = [-1, 0, 1, 2, -1, -4],
 *
 * A solution set is:
 * [
 *   [-1, 0, 1],
 *   [-1, -1, 2]
 * ]
 */
public class ThreeSum15 {
  public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    if (nums == null || nums.length < 3) {
      return res;
    }
    // sort array
    Arrays.sort(nums);
    for (int i = 0; i < nums.length - 2; i++) {
      // skip the duplicates
      if (i > 0 && nums[i] == nums[i - 1]) {
        continue;
      }
      int left = i + 1;
      int right = nums.length - 1;
      while (left < right)  {
        int currSum = nums[i] + nums[left] + nums[right];
        if (currSum == 0) {
          res.add(Arrays.asList(nums[i], nums[left], nums[right]));
          // from left to right, skip the duplicate number
          while (left < right && nums[left] == nums[left + 1]) {
            left++;
          }
          // from right to left, skip the duplicate number
          while (left < right && nums[right] == nums[right - 1]) {
            right--;
          }
          left++;
          right--;
        } else if (currSum < 0){ // move right when currSum < 0
          left++;
        } else {
          right--; // move to left when currSum > 0
        }
      }
    }
    return res;
  }

  public static void main(String[] args) {
    ThreeSum15 test = new ThreeSum15();
    System.out.println(test.threeSum(new int[]{-1, 0, -4, -1, 1, 2}));
  }
}
```

### [R] -
---


### [T] - [CLI-Improved](https://remysharp.com/2018/08/23/cli-improved)
---
Really CLI command tools, thought `ctrl+r` is alreay cool, until see this post, `fzf` fuzz find. and more.

Try it out, and it will help you save your ass~~

### [S] - 
---