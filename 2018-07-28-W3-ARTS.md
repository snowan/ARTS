## Week 3 ARTS
------
### [A] - LC: 863. All Nodes Distance K in Binary Tree
------
```java
package leetcode;

import java.util.*;

/**
 * 863. All Nodes Distance K in Binary Tree
 *
 * We are given a binary tree (with root node root), a target node, and an integer value K.
 *
 * Return a list of the values of all nodes that have a distance K from the target node.
 * The answer can be returned in any order.
 *
 *
 *
 * Example 1:
 *
 * Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2
 *
 * Output: [7,4,1]
 *
 * Explanation:
 * The nodes that are a distance 2 from the target node (with value 5)
 * have values 7, 4, and 1.
 *
 *
 *
 * Note that the inputs "root" and "target" are actually TreeNodes.
 * The descriptions of the inputs above are just serializations of these objects.
 *
 *
 * Note:
 *
 * The given tree is non-empty.
 * Each node in the tree has unique values 0 <= node.val <= 500.
 * The target node is a node in the tree.
 * 0 <= K <= 1000.
 */
public class AllNodesDistanceKinBT863 {
  class TreeNode {
    int val;
    TreeNode left, right;
    public TreeNode(int val) {
      this.val = val;
    }
  }

  public List<Integer> distanceK(TreeNode root, TreeNode target, int K) {
    if (root == null) return null;
    Map<TreeNode, TreeNode> map = new HashMap<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    // First BFS to record the path from children to root
    while (!queue.isEmpty()) {
      TreeNode curr = queue.poll();
      if (curr == target) break;
      if (curr.left != null) {
        map.put(curr.left, curr);
        queue.add(curr.left);
      }
      if (curr.right != null) {
        map.put(curr.right, curr);
        queue.add(curr.right);
      }
    }
    queue.clear();
    queue.add(target);
    Set<TreeNode> visited = new HashSet<>();
    visited.add(target);
    // Second BFS to record TreeNode that K distances
    while (K-- > 0) {
      if (queue.isEmpty()) return new LinkedList<>();
      for (int i = queue.size(); i > 0; i--) {
        TreeNode curr = queue.poll();
        if (curr.left != null && visited.add(curr.left)) queue.add(curr.left);
        if (curr.right != null && visited.add(curr.right)) queue.add(curr.right);
        if (map.get(curr) != null && visited.add(map.get(curr))) queue.add(map.get(curr));
      }
    }
    List<Integer> res  = new ArrayList<>();
    while (!queue.isEmpty()) res.add(queue.poll().val);

    return res;
  }
}
```

### [R] - [The original Google BigTable paper links](https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf)
------

Notes:
![alt text](https://github.com/snowan/ARTS/blob/W2-ARTS/images/bigtable-column.png)

![alt text](https://github.com/snowan/ARTS/blob/W2-ARTS/images/bigtable-store.png)

(This is how BigTable store and look up location informations.)

![alt text](https://github.com/snowan/ARTS/blob/W2-ARTS/images/bigtable-architechture.png)

![alt text](https://github.com/snowan/ARTS/blob/W2-ARTS/images/bigtable-arch.png)

(BigTable used LSM tree and WAL log to perform read/write operations.(GC ways to merge persistant data files)

**Write Process**

Write operation -> check well-formedness and ACL(from Chubby file) -> commit log -> memtable -> done

**Read Process**

Read opertion ->  check well-formedness and ACL(from Chubby file) -> merge view of memtable and SS Table -> done

Through the procudure of read/write operations we can see that HBase can have a good write throughput.


### [T] - 
------
[**bash argument case for args in $@**](https://stackoverflow.com/questions/14062895/bash-argument-case-for-args-in/14063511)

You can allow both --a=arg or -a arg options with a little more work:
```shell
START_DATE="$(date '+%Y-%m-%d')";
LAST_DATE="$(date '+%Y-%m-%d')";
while [[ $# -gt 0 ]] && [[ ."$1" = .--* ]] ;
do
    opt="$1";
    shift;              #expose next argument
    case "$opt" in
        "--" ) break 2;;
        "--first" )
           START_DATE="$1"; shift;;
        "--first="* )     # alternate format: --first=date
           START_DATE="${opt#*=}";;
        "--last" )
           LAST_DATE="$1"; shift;;
        "--last="* )
           LAST_DATE="${opt#*=}";;
        "--copy" )
           COPY=true;;
        "--remove" )
           REMOVE=true;;
        "--optional" )
           OPTIONAL="$optional_default";;     #set to some default value
        "--optional=*" )
           OPTIONAL="${opt#*=}";;             #take argument
        *) echo >&2 "Invalid option: $@"; exit 1;;
   esac
done
```
Note the --optional argument uses a default value if "=" is not used, else it sets the value in the normal way.

### [S] - [Why Percentiles don't work the way you think](https://www.vividcortex.com/blog/why-percentiles-dont-work-the-way-you-think)
------
Summary:

- Do not use average (Avg hides outlisers, cannot see them) 

- Outliers skew averages, so in a system with outliers, the average doesn’t represent typical behavior.

- Histogram percentile is wrong. (E.g. [StatsD issue](https://github.com/etsy/statsd/issues/157))
> "Percentiles are computed from a population of data, and have to be recalculated every time the population (time interval) changes. Time series databases with traditional metrics don’t have the original population." 
  
- Approximate percentiles can be computed from histograms, banded metrics, and other useful techniques.

- Regardless of their exact values, percentile metrics tend to a) show outlying behavior and b) get bigger when outlying behavior gets badder. Super useful. 

- Distribution metrics provides correct metrics (global metrics).



