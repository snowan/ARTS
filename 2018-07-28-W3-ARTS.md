## Week 3 ARTS
------
### [A] - LC: 863. All Nodes Distance K in Binary Tree
------
```java
package leetcode;

import java.util.*;

/**
 * 863. All Nodes Distance K in Binary Tree
 *
 * We are given a binary tree (with root node root), a target node, and an integer value K.
 *
 * Return a list of the values of all nodes that have a distance K from the target node.
 * The answer can be returned in any order.
 *
 *
 *
 * Example 1:
 *
 * Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2
 *
 * Output: [7,4,1]
 *
 * Explanation:
 * The nodes that are a distance 2 from the target node (with value 5)
 * have values 7, 4, and 1.
 *
 *
 *
 * Note that the inputs "root" and "target" are actually TreeNodes.
 * The descriptions of the inputs above are just serializations of these objects.
 *
 *
 * Note:
 *
 * The given tree is non-empty.
 * Each node in the tree has unique values 0 <= node.val <= 500.
 * The target node is a node in the tree.
 * 0 <= K <= 1000.
 */
public class AllNodesDistanceKinBT863 {
  class TreeNode {
    int val;
    TreeNode left, right;
    public TreeNode(int val) {
      this.val = val;
    }
  }

  public List<Integer> distanceK(TreeNode root, TreeNode target, int K) {
    if (root == null) return null;
    Map<TreeNode, TreeNode> map = new HashMap<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    // First BFS to record the path from children to root
    while (!queue.isEmpty()) {
      TreeNode curr = queue.poll();
      if (curr == target) break;
      if (curr.left != null) {
        map.put(curr.left, curr);
        queue.add(curr.left);
      }
      if (curr.right != null) {
        map.put(curr.right, curr);
        queue.add(curr.right);
      }
    }
    queue.clear();
    queue.add(target);
    Set<TreeNode> visited = new HashSet<>();
    visited.add(target);
    // Second BFS to record TreeNode that K distances
    while (K-- > 0) {
      if (queue.isEmpty()) return new LinkedList<>();
      for (int i = queue.size(); i > 0; i--) {
        TreeNode curr = queue.poll();
        if (curr.left != null && visited.add(curr.left)) queue.add(curr.left);
        if (curr.right != null && visited.add(curr.right)) queue.add(curr.right);
        if (map.get(curr) != null && visited.add(map.get(curr))) queue.add(map.get(curr));
      }
    }
    List<Integer> res  = new ArrayList<>();
    while (!queue.isEmpty()) res.add(queue.poll().val);

    return res;
  }
}
```

### [R] - [The original Google BigTable paper links](https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf)
------

Notes:
![alt text](https://github.com/snowan/ARTS/blob/W2-ARTS/images/bigtable-column.png)

![alt text](https://github.com/snowan/ARTS/blob/W2-ARTS/images/bigtable-store.png)

(This is how BigTable store and look up location informations.)

![alt text](https://github.com/snowan/ARTS/blob/W2-ARTS/images/bigtable-architechture.png)

![alt text](https://github.com/snowan/ARTS/blob/W2-ARTS/images/bigtable-arch.png)

(BigTable used LSM tree and WAL log to perform read/write operations.(GC ways to merge persistant data files)

**Write Process**

Write operation -> check well-formedness and ACL(from Chubby file) -> commit log -> memtable -> done

**Read Process**

Read opertion ->  check well-formedness and ACL(from Chubby file) -> merge view of memtable and SS Table -> done

Through the procudure of read/write operations we can see that HBase can have a good write throughput.


### [T] - 
------
[**bash argument case for args in $@**](https://stackoverflow.com/questions/14062895/bash-argument-case-for-args-in/14063511)

You can allow both --a=arg or -a arg options with a little more work:
```shell
START_DATE="$(date '+%Y-%m-%d')";
LAST_DATE="$(date '+%Y-%m-%d')";
while [[ $# -gt 0 ]] && [[ ."$1" = .--* ]] ;
do
    opt="$1";
    shift;              #expose next argument
    case "$opt" in
        "--" ) break 2;;
        "--first" )
           START_DATE="$1"; shift;;
        "--first="* )     # alternate format: --first=date
           START_DATE="${opt#*=}";;
        "--last" )
           LAST_DATE="$1"; shift;;
        "--last="* )
           LAST_DATE="${opt#*=}";;
        "--copy" )
           COPY=true;;
        "--remove" )
           REMOVE=true;;
        "--optional" )
           OPTIONAL="$optional_default";;     #set to some default value
        "--optional=*" )
           OPTIONAL="${opt#*=}";;             #take argument
        *) echo >&2 "Invalid option: $@"; exit 1;;
   esac
done
```
Note the --optional argument uses a default value if "=" is not used, else it sets the value in the normal way.

### [S] - [Building the Google Photos Web UI](https://medium.com/google-design/google-photos-45b714dfbed1)
------
Summary:

- **Scrubbable Photos** — the ability to quickly jump to any part of the photo library.

  - old ways: a). **pagination**  b) **infinite scrolling**
  
  - Third option: > A scrubbable photo grid presents a third option, one where the scrollbar behaves properly.

- **Justified Layout** — fill the width of the browser and preserve the aspect-ratio of each photo (no square crops).

  -  [line-wrapping problem](https://www.wikiwand.com/en/Line_wrap_and_word_wrap): The [Knuth & Plass line-breaking algorithm](http://defoe.sourceforge.net/folio/knuth-plass.html) is a well documented dynamic programming approach 
  
  >Instead of making decisions one line at a time, it lays out the entire section as a whole, so that each line may be influenced by the successive ones.
  
  a) Naive approach 
  b) Line Wrap 
  >While the naive approach will consider a **single** layout and pick it every time, the line-wrap algorithm considers millions, billions, trillions, and many more **unique** layouts and selects the **best** one.
  
  - The last layout trick we do is run the algorithm twice for each section. The first time we run it to lay out all the photos within segment, the second time we run it to lay out all the segments within the section.

- **60fps Scrolling** — ensuring the page remains responsive even when looking at many thousands of photos.
  
  - **Maintaining a constant-size DOM**: a) Track visible photos, keep in the document.  b) no longer visible photos, pull out from the document
  
  - **Minimizing changes**: a) position everything relative to its parents; b) batch and separate reads from writes
  
  - **Avoiding long running code**

- **Instantaneous Feel** —minimize the time waiting for anything to load.
  >It wasn’t necessary to be accurate, what mattered was it helped the page feel responsive.
  
  - Preemptively load content that they think you care about
  
  - Loading extremely small placeholders for as many as 4 or 5 full screens in the future to speed scroll requests.
  
  - Let browser to render the low-res tiles, then do swiftly (in 100ms), 
    -- usages: 
      a) scrolling through photos 
  
      b) Used into transitioning from a thumbnail into full-screen view
      
      c) Apply to empty section
  
  - check re-use thumbnail rather than re-download




