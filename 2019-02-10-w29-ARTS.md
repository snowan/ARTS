## Week 29 ARTS

### [A] - LC 300, 399, 301, 339, 65
---
```java
package leetcode;

/**
 * 300. Longest Increasing Subsequence
 *
 * Given an unsorted array of integers, find the length of longest increasing subsequence.
 *
 * Example:
 *
 * Input: [10,9,2,5,3,7,101,18]
 * Output: 4
 * Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
 * Note:
 *
 * There may be more than one LIS combination, it is only necessary for you to return the length.
 * Your algorithm should run in O(n2) complexity.
 * Follow up: Could you improve it to O(n log n) time complexity?
 */
public class LongestIncreasingSubsequence300 {
  /**
   * Solution: 1. brute force, for each item, any other item has two states, either be subsequence or not,
   * we have 2^n possible subsequences to visit.
   *
   * TC: O(2^n), SC: O(n^2)
   *
   * 2. Dynamic Programming (DP),
   * dp[i] to record ith item of longest size of subsequence
   * for given sub-array, nums[1...m] (1 <= m < len), we assume that we know the size
   * of subsequence for all arrays in nums[1...m] (1 <= m < len), meaning, we know dp[1], dp[2], ... dp[m],
   * now that we add one more item into array nums[m+1], how do we find out dp[m+1],
   * notice that we already know dp[1], dp[2], ... dp[m], so we can find the largest dp[i] (1 <= i < m + 1)
   * which satisfy with condition nums[i] < nums[m+1], then we can get dp[m+1] = nums[i] + 1, otherwise, dp[m+1] = 1
   * so we get equation:
   *
   * dp[i] = max(dp[j]) + 1 (1 <= j < i, and nums[j] < nums[i])
   * or dp[i] = 1 if no such j exsit in dp[1...j].
   *
   * for example: [5,2,4,6,3,7]
   * dp[] = [1,1,1,1,1,1]
   * i = 0, dp = [1,1,1,1,1,1]
   * i = 1, 2 < 5, dp = [1,1,1,1,1,1]
   * i = 3, 4 > 2, currMax = 1, dp = [1, 1, 2, 1,1,1]
   * i = 4, 6 > 4, currMax = 2 , 6 > 5, dp[j] = 1 < currMax, dp = [1,1,2,3,1,1]
   * i = 5, 3 < 6, 3 < 4 continue, 3 > 2, currMax = 1, dp =[1,1,2,3,2]
   * i = 6, 7 > 3, currMax = 2, 7 > 6, currMax = 3, 7 > 4, currMax = 3, dp = [1,1,2,3,2,4]
   *
   * max=4
   *
   * TC: O(n^2), SC: O(n)
   */
  public int lengthOfLIS(int[] nums) {
    if (nums == null) return 0;
    int len = nums.length;
    if (len < 2) return len;
    int[] dp = new int[len];
    int max = 0;
    for (int i = 0; i < len; i++) {
      dp[i] = 1;
      int currMax = 0;
      for (int j = 0; j < i; j++) {
        if (nums[j] < nums[i]) {
          // find the maxisum dp[j]
          currMax = Math.max(currMax, dp[j]);
        }
      }
      dp[i] = currMax + 1;
      max = Math.max(max, dp[i]);
    }
    return max;
  }
}
```
```java
package leetcode;

import java.util.*;

/**
 * 399. Evaluate Division
 *
 * Equations are given in the format A / B = k, where A and B are variables represented as strings,
 * and k is a real number (floating point number). Given some queries, return the answers.
 * If the answer does not exist, return -1.0.
 *
 * Example:
 * Given a / b = 2.0, b / c = 3.0.
 * queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .
 * return [6.0, 0.5, -1.0, 1.0, -1.0 ].
 *
 * The input is: vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries ,
 * where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector<double>.
 *
 * According to the example above:
 *
 * equations = [ ["a", "b"], ["b", "c"] ],
 * values = [2.0, 3.0],
 * queries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ].
 * The input is always valid. You may assume that evaluating the queries will result in no division by zero and
 * there is no contradiction.
 */
public class EvaluateDivistion399 {
  /**
   * Solution: can treat this as un-direct graph problem. and using a map of map, each variable as node, map contains
   * all possible node and values from given equation,
   * for example: a/b=2.0, b/c=3.0
   * map:[a: [b, 2.0]]
   *     [b: [a, 0.5],[c, 3.0]]
   *     [c: [b, 1/3.0]]
   *
   * after formatting map, DFS, with given query, we check whether node is in map, and scan the value(map), calculate results
   * for example: query: a/c=?
   * a-> [b, 2.0], a / b * b / c = a * c = 6.0
   *
   */
  public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {
    Map<String, Map<String, Double>> map = new HashMap<>();
    for (int i = 0; i < equations.length; i++) {
      String[] equation = equations[i];
      addEquation2Map(equation[0], equation[1], values[i], map);
      addEquation2Map(equation[1], equation[0], 1 / values[i], map);
    }

    double[] res = new double[queries.length];
    for (int i = 0; i < queries.length; i++) {
      String[] query = queries[i];
      Double currRes = dfs(query[0], query[1], map, new HashSet<>());
      res[i] = (currRes == null ? -1.0 : currRes);
    }

    System.out.println(Arrays.toString(res));
    return res;
  }

  private Double dfs(String num, String deNum, Map<String, Map<String, Double>> map, Set<String> visitedNode) {
    // here using num->denum, because this is undirect graph, a->b and b->a are different equations
    String currEquation = num + "->" + deNum;
    if (visitedNode.contains(currEquation)) {
      return null;
    }
    // map does not contain query node, meaning no possible equation
    if (!map.containsKey(num) || !map.containsKey(deNum)) {
      return null;
    }
    if (num.equals(deNum)) return 1.0;
    Map<String, Double> currMap = map.get(num);
    visitedNode.add(currEquation);
    for (String key : currMap.keySet()) {
      Double res = dfs(key, deNum, map, visitedNode);
      if (res != null) {
        return currMap.get(key) * res;
      }
    }
    visitedNode.remove(currEquation);
    return null;
  }

  private void addEquation2Map(String num, String deNum, double value, Map<String, Map<String, Double>> map) {
    if (!map.containsKey(num)) {
      map.put(num, new HashMap<>());
    }
    map.get(num).put(deNum, value);
  }
}
```
```java
package leetcode;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

/**
 * 339. Nested List Weight Sum
 *
 * Given a nested list of integers, return the sum of all integers in the list weighted by their depth.
 *
 * Each element is either an integer, or a list -- whose elements may also be integers or other lists.
 *
 * Example 1:
 *
 * Input: [[1,1],2,[1,1]]
 * Output: 10
 * Explanation: Four 1's at depth 2, one 2 at depth 1.
 * Example 2:
 *
 * Input: [1,[4,[6]]]
 * Output: 27
 * Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27.
 */


  // This is the interface that allows for creating nested lists.
  // You should not implement it, or speculate about its implementation
interface NestedInteger {
    // Constructor initializes an empty nested list.
//    public NestedInteger();

    // Constructor initializes a single integer.
//    public NestedInteger(int value);

    // @return true if this NestedInteger holds a single integer, rather than a nested list.
    public boolean isInteger();

    // @return the single integer that this NestedInteger holds, if it holds a single integer
    // Return null if this NestedInteger holds a nested list
    public Integer getInteger();

    // Set this NestedInteger to hold a single integer.
    public void setInteger(int value);

    // Set this NestedInteger to hold a nested list and adds a nested integer to it.
    public void add(NestedInteger ni);

    // @return the nested list that this NestedInteger holds, if it holds a nested list
    // Return null if this NestedInteger holds a single integer
    public List<NestedInteger> getList();
}

public class NestedListWeightSum339 {
  /**
   * Solution: nested input, recursion will be a good fit.
   * can treat nested input as tree, and using DFS or BFS(layer by layer) to add sum.
   *
   * TC: O(n) - n is the total nested elements.
   * SC: O(m) - m is the number of recursive calls on the stack, here we can say that m would hold the maximum layer(depth)
   * of nest.
   * for example:
   * [[1,1l,2,[1,1]] - would be 2 (2 depth).
   * [[[2,4]],6] - would be 3 (2 depth)
   */
  public int depthSum_DFS(List<NestedInteger> nestedIntegers) {
    if (nestedIntegers == null || nestedIntegers.size() == 0) return 0;
    return helper(nestedIntegers, 1);
  }
  private int helper(List<NestedInteger> nestedIntegers, int depth) {
    int sum = 0;
    for (NestedInteger ni : nestedIntegers) {
      if (ni.isInteger()) {
        sum += ni.getInteger() * depth;
      } else {
        sum += helper(ni.getList(), depth + 1);
      }
    }
    return sum;
  }

  public int depthSum_BFS(List<NestedInteger> nestedIntegers) {
    if (nestedIntegers == null || nestedIntegers.size() == 0) return 0;
    Queue<NestedInteger> queue = new LinkedList<>();
    addList2Queue(nestedIntegers, queue);
    int depth = 0;
    int sum = 0;
    while (!queue.isEmpty()) {
      int size = queue.size();
      depth++;
      while (size-- > 0) {
        NestedInteger curr = queue.poll();
        if (curr.isInteger()) {
          sum += curr.getInteger() * depth;
        } else {
          addList2Queue(curr.getList(), queue);
        }
      }
    }
    return sum;
  }
  private void addList2Queue(List<NestedInteger> nestedIntegers, Queue<NestedInteger> queue) {
    nestedIntegers.forEach(ni -> queue.add(ni));
  }
}
```
```java
package leetcode;


/**
 * 65. Valid Number
 *
 * Validate if a given string can be interpreted as a decimal number.
 *
 * Some examples:
 * "0" => true
 * " 0.1 " => true
 * "abc" => false
 * "1 a" => false
 * "2e10" => true
 * " -90e3   " => true
 * " 1e" => false
 * "e3" => false
 * " 6e-1" => true
 * " 99e2.5 " => false
 * "53.5e93" => true
 * " --6 " => false
 * "-+3" => false
 * "95a54e53" => false
 *
 * Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before
 * implementing one. However, here is a list of characters that can be in a valid decimal number:
 *
 * Numbers 0-9
 * Exponent - "e"
 * Positive/negative sign - "+"/"-"
 * Decimal point - "."
 * Of course, the context of these characters also matters in the input.
 *
 * Update (2015-02-10):
 * The signature of the C++ function had been updated. If you still see your function signature accepts a
 * const char * argument, please click the reload button to reset your code definition.
 *
 */
public class ValidNumber65 {
  /**
   * Solution: this problem is intuitive, but there are many corner cases need to be addressed accordingly.
   * following rules:
   * 1. dot cannot appear more than 1
   * 2. dot cannot appear after e
   * 3. e cannot appear more than 2
   * 4. e cannot appear on the first character
   * 5. '-' and '+' can either be the fist character or right after 'e'
   * 6. non number or the symbol '.','e','-','+' not allowed
   *
   * if follow above rules, scan the whole string character by character
   *
   * TC: O(n) - n the length of input string
   * SC: O(1) - no extra memory data structure used
   */
  public boolean isNumber(String s) {
    if (s == null || s.length() < 0) return false;
    boolean dotSeen = false;
    boolean eSeen = false;
    boolean numSeen = false;
    boolean numAfterESeen = true;
    for (int i = 0; i < s.length(); i++) {
      char ch = s.charAt(i);
      if (Character.isDigit(ch)) {
        numAfterESeen = true;
        numSeen = true;
      } else if (ch == '.') {
        if (dotSeen || eSeen) return false;
        dotSeen = true;
      } else if (ch == 'e' || ch == 'E') {
        if (eSeen || !numSeen) return false;
        eSeen = true;
        numAfterESeen = false;
      } else if (ch == '-' || ch == '+') {
        if (i != 0 && s.charAt(i - 1) != 'e') return false;
      } else return false;
    }
    return numSeen && numAfterESeen;
  }
}
```

### [R] - 
---

### [T] -
---


### [S] - 
---
