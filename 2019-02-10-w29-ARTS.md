## Week 29 ARTS

### [A] - LC 300
---
```java
package leetcode;

/**
 * 300. Longest Increasing Subsequence
 *
 * Given an unsorted array of integers, find the length of longest increasing subsequence.
 *
 * Example:
 *
 * Input: [10,9,2,5,3,7,101,18]
 * Output: 4
 * Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
 * Note:
 *
 * There may be more than one LIS combination, it is only necessary for you to return the length.
 * Your algorithm should run in O(n2) complexity.
 * Follow up: Could you improve it to O(n log n) time complexity?
 */
public class LongestIncreasingSubsequence300 {
  /**
   * Solution: 1. brute force, for each item, any other item has two states, either be subsequence or not,
   * we have 2^n possible subsequences to visit.
   *
   * TC: O(2^n), SC: O(n^2)
   *
   * 2. Dynamic Programming (DP),
   * dp[i] to record ith item of longest size of subsequence
   * for given sub-array, nums[1...m] (1 <= m < len), we assume that we know the size
   * of subsequence for all arrays in nums[1...m] (1 <= m < len), meaning, we know dp[1], dp[2], ... dp[m],
   * now that we add one more item into array nums[m+1], how do we find out dp[m+1],
   * notice that we already know dp[1], dp[2], ... dp[m], so we can find the largest dp[i] (1 <= i < m + 1)
   * which satisfy with condition nums[i] < nums[m+1], then we can get dp[m+1] = nums[i] + 1, otherwise, dp[m+1] = 1
   * so we get equation:
   *
   * dp[i] = max(dp[j]) + 1 (1 <= j < i, and nums[j] < nums[i])
   * or dp[i] = 1 if no such j exsit in dp[1...j].
   *
   * for example: [5,2,4,6,3,7]
   * dp[] = [1,1,1,1,1,1]
   * i = 0, dp = [1,1,1,1,1,1]
   * i = 1, 2 < 5, dp = [1,1,1,1,1,1]
   * i = 3, 4 > 2, currMax = 1, dp = [1, 1, 2, 1,1,1]
   * i = 4, 6 > 4, currMax = 2 , 6 > 5, dp[j] = 1 < currMax, dp = [1,1,2,3,1,1]
   * i = 5, 3 < 6, 3 < 4 continue, 3 > 2, currMax = 1, dp =[1,1,2,3,2]
   * i = 6, 7 > 3, currMax = 2, 7 > 6, currMax = 3, 7 > 4, currMax = 3, dp = [1,1,2,3,2,4]
   *
   * max=4
   *
   * TC: O(n^2), SC: O(n)
   */
  public int lengthOfLIS(int[] nums) {
    if (nums == null) return 0;
    int len = nums.length;
    if (len < 2) return len;
    int[] dp = new int[len];
    int max = 0;
    for (int i = 0; i < len; i++) {
      dp[i] = 1;
      int currMax = 0;
      for (int j = 0; j < i; j++) {
        if (nums[j] < nums[i]) {
          // find the maxisum dp[j]
          currMax = Math.max(currMax, dp[j]);
        }
      }
      dp[i] = currMax + 1;
      max = Math.max(max, dp[i]);
    }
    return max;
  }
}
```
