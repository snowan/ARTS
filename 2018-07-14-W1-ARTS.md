# Week 1 ARTS
### [A] - Algorithm
------

1. LC - Number of Connected Components in an Undirectly Graph (Java)

### Solution: [Union Find](https://www.wikiwand.com/en/Disjoint-set_data_structure)
Steps:
* Union all nodes into components
* Find number of components
```java
/**
 * Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes),
 * write a function to find the number of connected components in an undirected graph.
 *
 * Example 1:
 *
 *      0          3
 *
 *      |          |
 *
 *      1 --- 2    4
 *
 * Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.
 *
 * Example 2:
 *
 *      0           4
 *
 *      |           |
 *
 *      1 --- 2 --- 3
 *
 * Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.
 *
 *  Note:
 *
 * You can assume that no duplicate edges will appear in edges. Since all edges are undirected,
 * [0, 1] is the same as [1, 0] and thus will not appear together in edges.
 */
 
 public class NumberOfConnectedComponents {
  public int countComponents_uf(int n, int[][] edges) {
    // Initial parents
    int[] parents = new int[n];
    for (int i = 0; i < n; i++) {
      parents[i] = i;
    }
    // Union nodes 
    for (int[] edge : edges) {
      union(parents, edge[0], edge[1]); 
    }
    // find number of connected components (number of different parents), using Set
    Set<Integer> numOfComp = new HashSet<>();
    for (int i = 0; i < n; i++) {
      set.add(find(parents, i));
    }
    
    return set.size();
  }
  
  // find node
  public int find(int[] parents, int node) {
    if (parents[node] == node) return node;
    return find(parents, parents[node]);
  }
  
  // union nodes
  public void union(int[] parents, int n1, int n2) {
    int np1 = find(parents, n1);
    int np2 = find(parents, n2);
    parents[np1] = np2;
  }
 }
```
*Recommendation* : Learned Union Find algorithm though on [Coursera Algorithms Part I](https://www.coursera.org/learn/algorithms-part1) [Coursera Algorithms Part II](https://www.coursera.org/learn/algorithms-part2) by Princeton University. Highly Recommend this course, and it is free, hahaha.

Usually when I saw a graph relate problem, first solution came to mind is using DFS or BFS. For this question, we can also sovle it by DFS / BFS, and I think UF solution is much more elegant.


### [R] - Review
------
Recently I experimented with Hibernate Cache and CouchBase Cache, so today will review some caches, no matter it is distributed cache or local cache or Hibernate Cache, it is all about cache today. So today I will start some cache journeys.

As we all know cache is very important, we need to reduce Database hit as much as we can. So we're trying everything we can to add different layer caching.
Before hiting local Hibernate second level cache (here I experimented with Hibernate EHCache), we also added local EHCache per region and distributed Couchbase cache before local Hibernate EHCache. And we need to think carefully TTL(time to live) and MaxElementsInMemory. 
> Note: Caching is great, but it is better to cache non-transactional and read-only data

* [Hibernate Caching](https://www.tutorialspoint.com/hibernate/hibernate_caching.htm)
* [All about Hibernate second cache](https://dzone.com/articles/all-about-hibernate-second)
* [High performance with Distributed Caching Couchbase](http://info.couchbase.com/rs/302-GJY-034/images/High_Performance_With_Distributed_Caching_Couchbase.pdf)

### [T] - Tips
------


### [S] - Share
------



