## Week 9 ARTS

### [A] - LC: 880. Decoded String at Index
---
```java
package leetcode;

import java.util.*;

/**
 * 210. Course Schedule II
 *
 * There are a total of n courses you have to take, labeled from 0 to n-1.
 *
 * Some courses may have prerequisites, for example to take course 0 you have to first
 * take course 1, which is expressed as a pair: [0,1]
 *
 * Given the total number of courses and a list of prerequisite pairs, return the
 * ordering of courses you should take to finish all courses.
 *
 * There may be multiple correct orders, you just need to return one of them.
 * If it is impossible to finish all courses, return an empty array.
 *
 * Example 1:
 *
 * Input: 2, [[1,0]]
 * Output: [0,1]
 * Explanation: There are a total of 2 courses to take. To take course 1 you should have finished
 *              course 0. So the correct course order is [0,1] .
 * Example 2:
 *
 * Input: 4, [[1,0],[2,0],[3,1],[3,2]]
 * Output: [0,1,2,3] or [0,2,1,3]
 * Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both
 *              courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
 *              So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .
 * Note:
 *
 * The input prerequisites is a graph represented by a list of edges, not adjacency matrices.
 * Read more about how a graph is represented.
 * You may assume that there are no duplicate edges in the input prerequisites.
 */
public class CourseScheduleII210 {
  // BFS
  public int[] findOrder(int numCourses, int[][] prerequisites) {
    if (numCourses == 0) return null;
    int[] degree = new int[numCourses];
    
    // record course dependencies into map (key as a prerequisite course,
    // value as a list of dependencies courses
    Map<Integer, Set<Integer>> dependencies = new HashMap<>();
    for (int[] prePair : prerequisites) {
      int preCourse = prePair[1];
      int readyCourse = prePair[0];
      Set<Integer> currDependency = dependencies.containsKey(preCourse)
          ? dependencies.get(preCourse) : new HashSet<>();
      currDependency.add(readyCourse);
      dependencies.put(preCourse, currDependency);
  
      degree[readyCourse]++;
    }
    
    // add non dependencies course into queue
    Queue<Integer> queue = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
      if (degree[i] == 0) {
        queue.add(i);
      }
    }
    
    int[] courseOrder = new int[numCourses];
    int idx = 0;
    // start from non dependency course, layer by layer visit courses
    while (!queue.isEmpty()) {
      int curr = queue.poll();
      courseOrder[idx++] = curr;
      if (dependencies.containsKey(curr)) {
        for (int dep : dependencies.get(curr)) {
          if (--degree[dep] == 0) {
            queue.add(dep);
          }
        }
      }
    }
    
    printCourse(courseOrder);
    return idx == numCourses ? courseOrder : new int[]{};
  }
  
  private void printCourse(int[] courseOrder) {
    System.out.println("course order: ");
    for (int i : courseOrder) {
      System.out.print(i + " -> ");
    }
    System.out.println(" ");
  }
  
  public static void main(String[] args) {
    CourseScheduleII210 test = new CourseScheduleII210();
    System.out.println(test.findOrder(2, new int[][]{{1, 0}}));
    System.out.println(Arrays.asList(test.findOrder(4,
        new int[][]{{1, 0}, {2, 0}, {3, 1}, {3, 2}})));
  }
}

```
[R] - 
---

[T] -  
---

[S] - 
---