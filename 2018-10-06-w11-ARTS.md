## Week 9 ARTS

### [A] - LC: 880. Decoded String at Index
---
```java
package leetcode;

import java.util.*;

/**
 * 210. Course Schedule II
 *
 * There are a total of n courses you have to take, labeled from 0 to n-1.
 *
 * Some courses may have prerequisites, for example to take course 0 you have to first
 * take course 1, which is expressed as a pair: [0,1]
 *
 * Given the total number of courses and a list of prerequisite pairs, return the
 * ordering of courses you should take to finish all courses.
 *
 * There may be multiple correct orders, you just need to return one of them.
 * If it is impossible to finish all courses, return an empty array.
 *
 * Example 1:
 *
 * Input: 2, [[1,0]]
 * Output: [0,1]
 * Explanation: There are a total of 2 courses to take. To take course 1 you should have finished
 *              course 0. So the correct course order is [0,1] .
 * Example 2:
 *
 * Input: 4, [[1,0],[2,0],[3,1],[3,2]]
 * Output: [0,1,2,3] or [0,2,1,3]
 * Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both
 *              courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
 *              So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .
 * Note:
 *
 * The input prerequisites is a graph represented by a list of edges, not adjacency matrices.
 * Read more about how a graph is represented.
 * You may assume that there are no duplicate edges in the input prerequisites.
 */
public class CourseScheduleII210 {
  // BFS
  public int[] findOrder(int numCourses, int[][] prerequisites) {
    if (numCourses == 0) return null;
    int[] degree = new int[numCourses];
    
    // record course dependencies into map (key as a prerequisite course,
    // value as a list of dependencies courses
    Map<Integer, Set<Integer>> dependencies = new HashMap<>();
    for (int[] prePair : prerequisites) {
      int preCourse = prePair[1];
      int readyCourse = prePair[0];
      Set<Integer> currDependency = dependencies.containsKey(preCourse)
          ? dependencies.get(preCourse) : new HashSet<>();
      currDependency.add(readyCourse);
      dependencies.put(preCourse, currDependency);
  
      degree[readyCourse]++;
    }
    
    // add non dependencies course into queue
    Queue<Integer> queue = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
      if (degree[i] == 0) {
        queue.add(i);
      }
    }
    
    int[] courseOrder = new int[numCourses];
    int idx = 0;
    // start from non dependency course, layer by layer visit courses
    while (!queue.isEmpty()) {
      int curr = queue.poll();
      courseOrder[idx++] = curr;
      if (dependencies.containsKey(curr)) {
        for (int dep : dependencies.get(curr)) {
          if (--degree[dep] == 0) {
            queue.add(dep);
          }
        }
      }
    }
    
    printCourse(courseOrder);
    return idx == numCourses ? courseOrder : new int[]{};
  }
  
  private void printCourse(int[] courseOrder) {
    System.out.println("course order: ");
    for (int i : courseOrder) {
      System.out.print(i + " -> ");
    }
    System.out.println(" ");
  }
  
  public static void main(String[] args) {
    CourseScheduleII210 test = new CourseScheduleII210();
    System.out.println(test.findOrder(2, new int[][]{{1, 0}}));
    System.out.println(Arrays.asList(test.findOrder(4,
        new int[][]{{1, 0}, {2, 0}, {3, 1}, {3, 2}})));
  }
}

```

```java
package others;

import java.time.Instant;
import java.util.LinkedList;

/**
 * Interview Question: Event Counter
 *
 * Background
 * We want to count the number of times some event occured in the last N seconds.
 * The candidateâ€™s job is to implement these two methods:
 *
 * void eventOccurred();
 * int getNumEvents();
 *
 * Where eventOccurred() is called every time some event happens,
 * and getNumEvents returns the number of events that occurred in the last N seconds.
 *
 * Common questions:
 * The number of seconds, N, is a constant, i.e. final int N;
 * The events themselves have no timestamp data, we use the time eventOccurred was called as the event timestamp
 */
public class EventCounter {
  private static final int NUM_SECONDS = 1;
 
  class CounterItem {
    private long time;
    private long count;
  
    public CounterItem(long time, long count) {
      this.time = time;
      this.count = count;
    }
  }
  
  LinkedList<CounterItem> counterList = new LinkedList<>();
  private int totalNumOfEvents = 0;
  public synchronized void eventOccurred() {
    long currTime = Instant.now().toEpochMilli() / 1000;
    removeFirstTime(currTime);
    if (!counterList.isEmpty() && counterList.getLast().time == currTime) {
      counterList.getLast().count++;
    } else {
      counterList.add(new CounterItem(currTime, 1));
    }
    
    totalNumOfEvents++;
  }
  
  public synchronized int getNumEvents() {
    long currtime = Instant.now().toEpochMilli() / 1000;
    removeFirstTime(currtime);
    return totalNumOfEvents;
  }
  
  private void removeFirstTime(long time) {
    while (!counterList.isEmpty() && time - counterList.getFirst().time > NUM_SECONDS) {
      totalNumOfEvents -= counterList.removeFirst().count;
    }
  }
  
  public static void main(String[] args) {
    Thread t1 = new Thread();
    Thread t2 = new Thread();
    t1.start();
    EventCounter test = new EventCounter();
    for (int i = 0; i < 100000000; i++) {
      test.eventOccurred();
    }
  
    System.out.println(test.getNumEvents());
    t2.start();
    long start = Instant.now().toEpochMilli() / 1000;
    for (int i = 0; i < 100000000; i++) {
      test.eventOccurred();
    }
  
    System.out.println(Instant.now().toEpochMilli() / 1000 - start);
    System.out.println(test.getNumEvents());
  }
}
```

[R] - 
---

[T] -  
---

[S] - 
---