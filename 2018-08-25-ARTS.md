## Week 4 ARTS
------
### [A] - LC: 863. All Nodes Distance K in Binary Tree
------
```java
package leetcode;

import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

/**
 * 895. Maximum Frequency Stack
 *
 * Implement FreqStack, a class which simulates the operation of a stack-like data structure.
 *
 * FreqStack has two functions:
 *
 * push(int x), which pushes an integer x onto the stack.
 * pop(), which removes and returns the most frequent element in the stack.
 * If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.
 *
 *
 * Example 1:
 *
 * Input:
 * ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
 * [[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
 * Output: [null,null,null,null,null,null,null,5,7,5,4]
 * Explanation:
 * After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:
 *
 * pop() -> returns 5, as 5 is the most frequent.
 * The stack becomes [5,7,5,7,4].
 *
 * pop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.
 * The stack becomes [5,7,5,4].
 *
 * pop() -> returns 5.
 * The stack becomes [5,7,4].
 *
 * pop() -> returns 4.
 * The stack becomes [5,7].
 *
 *
 * Note:
 *
 * Calls to FreqStack.push(int x) will be such that 0 <= x <= 10^9.
 * It is guaranteed that FreqStack.pop() won't be called if the stack has zero elements.
 * The total number of FreqStack.push calls will not exceed 10000 in a single test case.
 * The total number of FreqStack.pop calls will not exceed 10000 in a single test case.
 * The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.
 */
public class MaximumFrequencyStack895 {

  class Node {
    int val;
    int freq;
    int pushIdx;

    public Node(int val, int freq, int pushIdx) {
      this.val = val;
      this.freq = freq;
      this.pushIdx = pushIdx;
    }
  }

  PriorityQueue<Node> pq;
  Map<Integer, Integer> map;
  int pushIdx;
  public MaximumFrequencyStack895() {
    pushIdx = 0;
    pq = new PriorityQueue<>((a, b) -> {
     return (a.freq != b.freq) ? b.freq - a.freq : b.pushIdx - a.pushIdx;
    });
    map = new HashMap<>();
  }

  public void push(int x) {
    map.put(x, map.getOrDefault(x, 0) + 1);
    Node node = new Node(x, map.get(x), pushIdx++);
    pq.offer(node);
  }

  public int pop() {
    return pq.poll().val;
  }

  public static void main(String[] args) {
    MaximumFrequencyStack895 test = new MaximumFrequencyStack895();
    test.push(5);
    test.push(7);
    test.push(5);
    test.push(7);
    test.push(5);
    test.push(4);

    System.out.println(test.pop());
    System.out.println(test.pop());
    System.out.println(test.pop());
    System.out.println(test.pop());
    System.out.println(test.pop());
    System.out.println(test.pop());
  }
}

```

### [R] - [Airbnb’s 10 Takeaways from Moving to Microservices](https://thenewstack.io/airbnbs-10-takeaways-moving-microservices/)
------
With microservices widely used across many companies, Monolith is becoming heavier and single point failure, etc drawbacks, we started to think break Monolith into several microservices, (we are applying new features implementing with Microservices). To start this journey, need to review the whole monolith, and all the dependencies among it.

Review Airbnb's takeways to help break the ice for us:
- Build up a good DevOps culture, build CI/CD pipelines to auto build and deploy microservices.

- Configuration as Code (Currently all configs on Prod are strictly controlled by DevOps team)

- Set up monitoring and alerting system

- CI/CD (Already set up CI/CD pipeline for Microservices build and deploy)

- Automate (Semi-automate the whole process, need to work on fully automate)

- Services own their Data (Let microservices team fully be responsible for their Data)

- Break apart the Monolith (currently we're reviewing our giant Monlith, and re-architecture this giant into small pieces)

- Standardize Service Creation (We're adopting this idea to craft our service team)

Current stage is testing one service we've taking out from Monolith, set up mornitoring system to show lantencies and performance diff.


### [T] - Configuring your service for [Envoy](https://www.envoyproxy.io/docs/envoy/latest/intro/what_is_envoy)
------
- Create a [headless Kubernetes Services](https://kubernetes.io/docs/concepts/services-networking/service/#headless-services) for your Microservices.

  - A headless Service allow Envoy to fetch the full list of Pod IPs via DNS and load balance across them.
  - If the server isn't headless, Envoy only gets the Service ClusterIP when it does a DNS lookup. 
  - Despite losing lots of useful granularity in access logs and metrics, this technically can work for a Service which doesn't use persistent connections.
  ```
  apiVersion: v1
  kind: Service
  metadata:
    name: [serviceName]-headless
    namespace: {{.Values.namespace}}
    labels:
      name: [serviceName].headless
  spec:
    clusterIP: None // Note: !important
    ports:
      - port: {{.Values.[serviceName].Ports.grpc}}
        protocol: TCP
    selector:
      app: [serviceName].grpc
  ```
  
- Add **Cluster** and **Route** configuration to Envoy's config file

  - The Cluster degines a set of backends that Envoy can route traffic to. 
  
  - The Route instructs Envoy to send certain requests to Cluster.

- Config Envoy Ingress Host/Port to connect to service


More details on Google Kubernetes [*official document*](https://kubernetes.io/docs/concepts/services-networking/service/)

### [S] - [Building the Google Photos Web UI](https://medium.com/google-design/google-photos-45b714dfbed1)
------
Summary:

- **Scrubbable Photos** — the ability to quickly jump to any part of the photo library.

  - old ways: a). **pagination**  b) **infinite scrolling**
  
  - Third option: > A scrubbable photo grid presents a third option, one where the scrollbar behaves properly.

- **Justified Layout** — fill the width of the browser and preserve the aspect-ratio of each photo (no square crops).

  -  [line-wrapping problem](https://www.wikiwand.com/en/Line_wrap_and_word_wrap): The [Knuth & Plass line-breaking algorithm](http://defoe.sourceforge.net/folio/knuth-plass.html) is a well documented dynamic programming approach 
  
  >Instead of making decisions one line at a time, it lays out the entire section as a whole, so that each line may be influenced by the successive ones.
  
  a) Naive approach 
  b) Line Wrap 
  >While the naive approach will consider a **single** layout and pick it every time, the line-wrap algorithm considers millions, billions, trillions, and many more **unique** layouts and selects the **best** one.
  
  - The last layout trick we do is run the algorithm twice for each section. The first time we run it to lay out all the photos within segment, the second time we run it to lay out all the segments within the section.

- **60fps Scrolling** — ensuring the page remains responsive even when looking at many thousands of photos.
  
  - **Maintaining a constant-size DOM**: a) Track visible photos, keep in the document.  b) no longer visible photos, pull out from the document
  
  - **Minimizing changes**: a) position everything relative to its parents; b) batch and separate reads from writes
  
  - **Avoiding long running code**

- **Instantaneous Feel** —minimize the time waiting for anything to load.
  >It wasn’t necessary to be accurate, what mattered was it helped the page feel responsive.
  
  - Preemptively load content that they think you care about
  
  - Loading extremely small placeholders for as many as 4 or 5 full screens in the future to speed scroll requests.
  
  - Let browser to render the low-res tiles, then do swiftly (in 100ms), 
    -- usages: 
      a) scrolling through photos 
  
      b) Used into transitioning from a thumbnail into full-screen view
      
      c) Apply to empty section
  
  - check re-use thumbnail rather than re-download


