## Week 4 ARTS
------
### [A] - LC: 895. Maximum Frequency Stack
------
```java
package leetcode;

import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

/**
 * 895. Maximum Frequency Stack
 *
 * Implement FreqStack, a class which simulates the operation of a stack-like data structure.
 *
 * FreqStack has two functions:
 *
 * push(int x), which pushes an integer x onto the stack.
 * pop(), which removes and returns the most frequent element in the stack.
 * If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.
 *
 *
 * Example 1:
 *
 * Input:
 * ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
 * [[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
 * Output: [null,null,null,null,null,null,null,5,7,5,4]
 * Explanation:
 * After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:
 *
 * pop() -> returns 5, as 5 is the most frequent.
 * The stack becomes [5,7,5,7,4].
 *
 * pop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.
 * The stack becomes [5,7,5,4].
 *
 * pop() -> returns 5.
 * The stack becomes [5,7,4].
 *
 * pop() -> returns 4.
 * The stack becomes [5,7].
 *
 *
 * Note:
 *
 * Calls to FreqStack.push(int x) will be such that 0 <= x <= 10^9.
 * It is guaranteed that FreqStack.pop() won't be called if the stack has zero elements.
 * The total number of FreqStack.push calls will not exceed 10000 in a single test case.
 * The total number of FreqStack.pop calls will not exceed 10000 in a single test case.
 * The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.
 */
public class MaximumFrequencyStack895 {

  class Node {
    int val;
    int freq;
    int pushIdx;

    public Node(int val, int freq, int pushIdx) {
      this.val = val;
      this.freq = freq;
      this.pushIdx = pushIdx;
    }
  }

  PriorityQueue<Node> pq;
  Map<Integer, Integer> map;
  int pushIdx;
  public MaximumFrequencyStack895() {
    // initial params
    pushIdx = 0;
    pq = new PriorityQueue<>((a, b) -> {
     return (a.freq != b.freq) ? b.freq - a.freq : b.pushIdx - a.pushIdx;
    });
    map = new HashMap<>();
  }

  public void push(int x) {
    // mantain priorityqueue value
    map.put(x, map.getOrDefault(x, 0) + 1);
    Node node = new Node(x, map.get(x), pushIdx++);
    pq.offer(node);
  }

  public int pop() {
    int res = pq.poll().val;
    // mantain map value
    if (map.get(res) - 1 == 0) map.remove(res);
    else map.put(res, map.get(res) - 1);
    return res;
  }

  public static void main(String[] args) {
    MaximumFrequencyStack895 test = new MaximumFrequencyStack895();
    test.push(5);
    test.push(7);
    test.push(5);
    test.push(7);
    test.push(5);
    test.push(4);

    System.out.println(test.pop());
    System.out.println(test.pop());
    System.out.println(test.pop());
    System.out.println(test.pop());
    System.out.println(test.pop());
    System.out.println(test.pop());
  }
}

```

### [R] - Docker Implement MySql master-slave instances on a single machine (Mac) - For local test only
------
Recently I am working on setting up MySql Store replication, first I need to set up multiple MySql instances on my local (single machine). So I reviewed some examples and using Docker for this task, simply create multiple docker containers for instances and expose MySql ports for localhost connection.

MySql master slave replication, below pic from [MySQL Master-Slave Replication on the Same Machine](https://www.toptal.com/mysql/mysql-master-slave-replication-tutorial)

![alt text](https://github.com/snowan/ARTS/blob/w5-arts/images/mysql-master-slave.png)

- Using docker compose for Master and Slave containers, example:
```yaml
version: "3.3"
services:
  mysql-master: &mysql
    image: mysql:5.7.20
    container_name: mysql-master
    restart: always
    env_file:
      - env/base.env
      - env/master.env
    environment:
      - MYSQL_ROOT_PASSWORD=root_pwd
    ports:
      - "3306:3306"
    expose:
      - "3306"
    volumes:
      - mysql-master-data:/var/lib/mysql
    command: [  # using a custom MySql configuration file
      "--log-bin=mysql-bin",
      "--server-id=1",
      "--character-set-server=utf8mb4",
      "--collation-server=utf8mb4_unicode_ci",
      "--innodb_flush_log_at_trx_commit=1",
      "--sync_binlog=1"
      ]

  mysql-slave: &mysql-slave
    <<: *mysql
    container_name: mysql-slave
    environment:
      - MYSQL_ROOT_PASSWORD=root
      - MASTER_MYSQL_ROOT_PASSWORD=root_pwd
    ports:
      - "3307:3306"
    depends_on:
      - mysql-master
    volumes:
      - mysql-slave-data:/var/lib/mysql
    command: [
      "--server-id=2", # server id must be different than master server id
      "--character-set-server=utf8mb4",
      "--collation-server=utf8mb4_unicode_ci",
      ]
 

volumes:
  mysql-master-data:
  mysql-slave-data:
```
#### [Using a custom MYSQL configuration file](https://hub.docker.com/_/mysql/)
>*Configuration without a cnf file*
Many configuration options can be passed as flags to mysqld. This will give you the flexibility to customize the container without needing a cnf file. For example, if you want to change the default encoding and collation for all tables to use UTF-8 (utf8mb4) just run the following:
>
>`$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci`
>
>If you would like to see a complete list of available options, just run:
>
>`$ docker run -it --rm mysql:tag --verbose --help`



### [T] - Configuring your service for [Envoy](https://www.envoyproxy.io/docs/envoy/latest/intro/what_is_envoy)
------
- Create a [headless Kubernetes Services](https://kubernetes.io/docs/concepts/services-networking/service/#headless-services) for your Microservices.

  - A headless Service allow Envoy to fetch the full list of Pod IPs via DNS and load balance across them.
  - If the server isn't headless, Envoy only gets the Service ClusterIP when it does a DNS lookup. 
  - Despite losing lots of useful granularity in access logs and metrics, this technically can work for a Service which doesn't use persistent connections.
  ```
  apiVersion: v1
  kind: Service
  metadata:
    name: [serviceName]-headless
    namespace: {{.Values.namespace}}
    labels:
      name: [serviceName].headless
  spec:
    clusterIP: None // Note: !important
    ports:
      - port: {{.Values.[serviceName].Ports.grpc}}
        protocol: TCP
    selector:
      app: [serviceName].grpc
  ```
  
- Add **Cluster** and **Route** configuration to Envoy's config file

  - The Cluster degines a set of backends that Envoy can route traffic to. 
  
  - The Route instructs Envoy to send certain requests to Cluster.

- Config Envoy Ingress Host/Port to connect to service


More details on Google Kubernetes [*official document*](https://kubernetes.io/docs/concepts/services-networking/service/)

### [S] - [Building the Google Photos Web UI](https://medium.com/google-design/google-photos-45b714dfbed1)
------
Summary:

- **Scrubbable Photos** — the ability to quickly jump to any part of the photo library.

  - old ways: a). **pagination**  b) **infinite scrolling**
  
  - Third option: > A scrubbable photo grid presents a third option, one where the scrollbar behaves properly.

- **Justified Layout** — fill the width of the browser and preserve the aspect-ratio of each photo (no square crops).

  -  [line-wrapping problem](https://www.wikiwand.com/en/Line_wrap_and_word_wrap): The [Knuth & Plass line-breaking algorithm](http://defoe.sourceforge.net/folio/knuth-plass.html) is a well documented dynamic programming approach 
  
  >Instead of making decisions one line at a time, it lays out the entire section as a whole, so that each line may be influenced by the successive ones.
  
  a) Naive approach 
  b) Line Wrap 
  >While the naive approach will consider a **single** layout and pick it every time, the line-wrap algorithm considers millions, billions, trillions, and many more **unique** layouts and selects the **best** one.
  
  - The last layout trick we do is run the algorithm twice for each section. The first time we run it to lay out all the photos within segment, the second time we run it to lay out all the segments within the section.

- **60fps Scrolling** — ensuring the page remains responsive even when looking at many thousands of photos.
  
  - **Maintaining a constant-size DOM**: a) Track visible photos, keep in the document.  b) no longer visible photos, pull out from the document
  
  - **Minimizing changes**: a) position everything relative to its parents; b) batch and separate reads from writes
  
  - **Avoiding long running code**

- **Instantaneous Feel** —minimize the time waiting for anything to load.
  >It wasn’t necessary to be accurate, what mattered was it helped the page feel responsive.
  
  - Preemptively load content that they think you care about
  
  - Loading extremely small placeholders for as many as 4 or 5 full screens in the future to speed scroll requests.
  
  - Let browser to render the low-res tiles, then do swiftly (in 100ms), 
    -- usages: 
      a) scrolling through photos 
  
      b) Used into transitioning from a thumbnail into full-screen view
      
      c) Apply to empty section
  
  - check re-use thumbnail rather than re-download


